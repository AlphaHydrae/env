[color]
  diff = auto
  status = auto
  branch = auto
  interactive = auto
[alias]
  d = diff
  dc = diff --cached
  dn = diff --name-status
  s = status
  sta = status
  a = add --all .
  ai = add --interactive
  ap = add --patch
  b = branch
  ba = branch -a
  c = checkout
  cb = checkout -b
  f = fetch
  fp = fetch --prune
  fa = fetch --all --prune
  dev = checkout develop
  develop = checkout develop
  mas = checkout master
  master = checkout master
  rh = reset HEAD

  cp = cherry-pick
  cpn = cherry-pick -n

  lp = log --patch

  # commit graph
  g = log --oneline --graph --decorate
  # commit graph (all refs)
  ga = log --oneline --graph --decorate --all
  # commit graph simplified by decoration
  gs = log --oneline --graph --decorate --simplify-by-decoration
  # commit graph simplified by decoration (all refs)
  gas = log --oneline --graph --decorate --all --simplify-by-decoration

  # miscellaneous
  w = rebase -i
  war = rebase -i

  # stage new, modified and removed files
  wip = !"git add -A; git ls-files --deleted -z | xargs -0 git rm"

  # prune local branches that have been merged (excluding master and the current branch)
  pl = !"git branch --merged|grep -v "\\*"|grep -v master|xargs -n 1 git branch -d"

  # set upstream to origin/<branch> or <remote>/<branch>
  #    sup <branch>
  #    sup <remote> <branch>
  sup = "!f() { if [ -z $1 ]; then echo 'Branch name required.' 1>&2; return 1; fi; if [ -z $2 ]; then set origin $1; fi; git branch --set-upstream $2 $1/$2; }; f"

  # create branch with upstream set to origin/<branch> or <remote>/<branch>
  #    bru <branch>
  #    bru <remote> <branch>
  bru = "!f() { if [ -z $1 ]; then echo 'Branch name required.' 1>&2; return 1; fi; if [ -z $2 ]; then set origin $1; fi; git checkout -b $2 $1/$2; }; f"
[core]
  excludesfile = ~/.gitignore
[include]
  path = .gitprivate
[push]
  default = simple
[merge]
	conflictstyle = diff3
[rerere]
	enabled = true
